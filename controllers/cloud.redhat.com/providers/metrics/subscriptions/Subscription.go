// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package v1alpha1

import (
	"encoding/json"
	"fmt"

	apiextensions "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func init() {
	SchemeBuilder.Register(&Subscription{}, &SubscriptionList{})
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemProjectedSourcesElemSecretItemsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemProjectedSourcesElemSecretItemsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemProjectedSourcesElemSecretItemsElem(plain)
	return nil
}

// Selects a key of a ConfigMap.
type SubscriptionSpecConfigEnvElemValueFromConfigMapKeyRef struct {
	// The key to select.
	Key string `json:"key"`

	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `json:"name,omitempty"`

	// Specify whether the ConfigMap or its key must be defined
	Optional *bool `json:"optional,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigEnvElemValueFromConfigMapKeyRef) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key: required")
	}
	type Plain SubscriptionSpecConfigEnvElemValueFromConfigMapKeyRef
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigEnvElemValueFromConfigMapKeyRef(plain)
	return nil
}

// Selects a field of the pod: supports metadata.name, metadata.namespace,
// `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName,
// spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
type SubscriptionSpecConfigEnvElemValueFromFieldRef struct {
	// Version of the schema the FieldPath is written in terms of, defaults to "v1".
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Path of the field to select in the specified API version.
	FieldPath string `json:"fieldPath"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigEnvElemValueFromFieldRef) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["fieldPath"]; !ok || v == nil {
		return fmt.Errorf("field fieldPath: required")
	}
	type Plain SubscriptionSpecConfigEnvElemValueFromFieldRef
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigEnvElemValueFromFieldRef(plain)
	return nil
}

// Selects a resource of the container: only resources limits and requests
// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu,
// requests.memory and requests.ephemeral-storage) are currently supported.
type SubscriptionSpecConfigEnvElemValueFromResourceFieldRef struct {
	// Container name: required for volumes, optional for env vars
	ContainerName *string `json:"containerName,omitempty"`

	// Specifies the output format of the exposed resources, defaults to "1"
	Divisor *apiextensions.JSON `json:"divisor,omitempty"`

	// Required: resource to select
	Resource string `json:"resource"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigEnvElemValueFromResourceFieldRef) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["resource"]; !ok || v == nil {
		return fmt.Errorf("field resource: required")
	}
	type Plain SubscriptionSpecConfigEnvElemValueFromResourceFieldRef
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigEnvElemValueFromResourceFieldRef(plain)
	return nil
}

// Selects a key of a secret in the pod's namespace
type SubscriptionSpecConfigEnvElemValueFromSecretKeyRef struct {
	// The key of the secret to select from.  Must be a valid secret key.
	Key string `json:"key"`

	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `json:"name,omitempty"`

	// Specify whether the Secret or its key must be defined
	Optional *bool `json:"optional,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigEnvElemValueFromSecretKeyRef) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key: required")
	}
	type Plain SubscriptionSpecConfigEnvElemValueFromSecretKeyRef
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigEnvElemValueFromSecretKeyRef(plain)
	return nil
}

// Source for the environment variable's value. Cannot be used if value is not
// empty.
type SubscriptionSpecConfigEnvElemValueFrom struct {
	// Selects a key of a ConfigMap.
	ConfigMapKeyRef *SubscriptionSpecConfigEnvElemValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty"`

	// Selects a field of the pod: supports metadata.name, metadata.namespace,
	// `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName,
	// spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
	FieldRef *SubscriptionSpecConfigEnvElemValueFromFieldRef `json:"fieldRef,omitempty"`

	// Selects a resource of the container: only resources limits and requests
	// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu,
	// requests.memory and requests.ephemeral-storage) are currently supported.
	ResourceFieldRef *SubscriptionSpecConfigEnvElemValueFromResourceFieldRef `json:"resourceFieldRef,omitempty"`

	// Selects a key of a secret in the pod's namespace
	SecretKeyRef *SubscriptionSpecConfigEnvElemValueFromSecretKeyRef `json:"secretKeyRef,omitempty"`
}

// EnvVar represents an environment variable present in a Container.
type SubscriptionSpecConfigEnvElem struct {
	// Name of the environment variable. Must be a C_IDENTIFIER.
	Name string `json:"name"`

	// Variable references $(VAR_NAME) are expanded using the previously defined
	// environment variables in the container and any service environment variables.
	// If a variable cannot be resolved, the reference in the input string will be
	// unchanged. Double $$ are reduced to a single $, which allows for escaping the
	// $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal
	// "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether
	// the variable exists or not. Defaults to "".
	Value *string `json:"value,omitempty"`

	// Source for the environment variable's value. Cannot be used if value is not
	// empty.
	ValueFrom *SubscriptionSpecConfigEnvElemValueFrom `json:"valueFrom,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigEnvElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain SubscriptionSpecConfigEnvElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigEnvElem(plain)
	return nil
}

// The ConfigMap to select from
type SubscriptionSpecConfigEnvFromElemConfigMapRef struct {
	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `json:"name,omitempty"`

	// Specify whether the ConfigMap must be defined
	Optional *bool `json:"optional,omitempty"`
}

// The Secret to select from
type SubscriptionSpecConfigEnvFromElemSecretRef struct {
	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `json:"name,omitempty"`

	// Specify whether the Secret must be defined
	Optional *bool `json:"optional,omitempty"`
}

// EnvFromSource represents the source of a set of ConfigMaps
type SubscriptionSpecConfigEnvFromElem struct {
	// The ConfigMap to select from
	ConfigMapRef *SubscriptionSpecConfigEnvFromElemConfigMapRef `json:"configMapRef,omitempty"`

	// An optional identifier to prepend to each key in the ConfigMap. Must be a
	// C_IDENTIFIER.
	Prefix *string `json:"prefix,omitempty"`

	// The Secret to select from
	SecretRef *SubscriptionSpecConfigEnvFromElemSecretRef `json:"secretRef,omitempty"`
}

// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that
// node. More info:
// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
// type SubscriptionSpecConfigNodeSelector map[string]interface{}

// Limits describes the maximum amount of compute resources allowed. More info:
// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
// type SubscriptionSpecConfigResourcesLimits map[string]interface{}

// type SubscriptionMetadata map[string]interface{}

// Resources represents compute resources required by this container. Immutable.
// More info:
// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
type SubscriptionSpecConfigResources struct {
	// Limits describes the maximum amount of compute resources allowed. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Limits *apiextensions.JSON `json:"limits,omitempty"`

	// Requests describes the minimum amount of compute resources required. If
	// Requests is omitted for a container, it defaults to Limits if that is
	// explicitly specified, otherwise to an implementation-defined value. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Requests *apiextensions.JSON `json:"requests,omitempty"`
}

// A label selector requirement is a selector that contains values, a key, and an
// operator that relates the key and values.
type SubscriptionSpecConfigSelectorMatchExpressionsElem struct {
	// key is the label key that the selector applies to.
	Key string `json:"key"`

	// operator represents a key's relationship to a set of values. Valid operators
	// are In, NotIn, Exists and DoesNotExist.
	Operator string `json:"operator"`

	// values is an array of string values. If the operator is In or NotIn, the values
	// array must be non-empty. If the operator is Exists or DoesNotExist, the values
	// array must be empty. This array is replaced during a strategic merge patch.
	Values []string `json:"values,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigSelectorMatchExpressionsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key: required")
	}
	if v, ok := raw["operator"]; !ok || v == nil {
		return fmt.Errorf("field operator: required")
	}
	type Plain SubscriptionSpecConfigSelectorMatchExpressionsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigSelectorMatchExpressionsElem(plain)
	return nil
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the
// matchLabels map is equivalent to an element of matchExpressions, whose key field
// is "key", the operator is "In", and the values array contains only "value". The
// requirements are ANDed.
// type SubscriptionSpecConfigSelectorMatchLabels map[string]interface{}

// Selector is the label selector for pods to be configured. Existing ReplicaSets
// whose pods are selected by this will be the ones affected by this deployment. It
// must match the pod template's labels.
type SubscriptionSpecConfigSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are
	// ANDed.
	MatchExpressions []SubscriptionSpecConfigSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// matchLabels is a map of {key,value} pairs. A single {key,value} in the
	// matchLabels map is equivalent to an element of matchExpressions, whose key
	// field is "key", the operator is "In", and the values array contains only
	// "value". The requirements are ANDed.
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

// The pod this Toleration is attached to tolerates any taint that matches the
// triple <key,value,effect> using the matching operator <operator>.
type SubscriptionSpecConfigTolerationsElem struct {
	// Effect indicates the taint effect to match. Empty means match all taint
	// effects. When specified, allowed values are NoSchedule, PreferNoSchedule and
	// NoExecute.
	Effect *string `json:"effect,omitempty"`

	// Key is the taint key that the toleration applies to. Empty means match all
	// taint keys. If the key is empty, operator must be Exists; this combination
	// means to match all values and all keys.
	Key *string `json:"key,omitempty"`

	// Operator represents a key's relationship to the value. Valid operators are
	// Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for
	// value, so that a pod can tolerate all taints of a particular category.
	Operator *string `json:"operator,omitempty"`

	// TolerationSeconds represents the period of time the toleration (which must be
	// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By
	// default, it is not set, which means tolerate the taint forever (do not evict).
	// Zero and negative values will be treated as 0 (evict immediately) by the
	// system.
	TolerationSeconds *int `json:"tolerationSeconds,omitempty"`

	// Value is the taint value the toleration matches to. If the operator is Exists,
	// the value should be empty, otherwise just a regular string.
	Value *string `json:"value,omitempty"`
}

// VolumeMount describes a mounting of a Volume within a container.
type SubscriptionSpecConfigVolumeMountsElem struct {
	// Path within the container at which the volume should be mounted.  Must not
	// contain ':'.
	MountPath string `json:"mountPath"`

	// mountPropagation determines how mounts are propagated from the host to
	// container and the other way around. When not set, MountPropagationNone is used.
	// This field is beta in 1.10.
	MountPropagation *string `json:"mountPropagation,omitempty"`

	// This must match the Name of a Volume.
	Name string `json:"name"`

	// Mounted read-only if true, read-write otherwise (false or unspecified).
	// Defaults to false.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// Path within the volume from which the container's volume should be mounted.
	// Defaults to "" (volume's root).
	SubPath *string `json:"subPath,omitempty"`

	// Expanded path within the volume from which the container's volume should be
	// mounted. Behaves similarly to SubPath but environment variable references
	// $(VAR_NAME) are expanded using the container's environment. Defaults to ""
	// (volume's root). SubPathExpr and SubPath are mutually exclusive.
	SubPathExpr *string `json:"subPathExpr,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumeMountsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["mountPath"]; !ok || v == nil {
		return fmt.Errorf("field mountPath: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain SubscriptionSpecConfigVolumeMountsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumeMountsElem(plain)
	return nil
}

// AWSElasticBlockStore represents an AWS Disk resource that is attached to a
// kubelet's host machine and then exposed to the pod. More info:
// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
type SubscriptionSpecConfigVolumesElemAwsElasticBlockStore struct {
	// Filesystem type of the volume that you want to mount. Tip: Ensure that the
	// filesystem type is supported by the host operating system. Examples: "ext4",
	// "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO:
	// how do we prevent errors in the filesystem from compromising the machine
	FsType *string `json:"fsType,omitempty"`

	// The partition in the volume that you want to mount. If omitted, the default is
	// to mount by volume name. Examples: For volume /dev/sda1, you specify the
	// partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you
	// can leave the property empty).
	Partition *int `json:"partition,omitempty"`

	// Specify "true" to force and set the ReadOnly property in VolumeMounts to
	// "true". If omitted, the default is "false". More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
	ReadOnly *bool `json:"readOnly,omitempty"`

	// Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More
	// info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
	VolumeID string `json:"volumeID"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemAwsElasticBlockStore) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["volumeID"]; !ok || v == nil {
		return fmt.Errorf("field volumeID: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemAwsElasticBlockStore
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemAwsElasticBlockStore(plain)
	return nil
}

// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the
// pod.
type SubscriptionSpecConfigVolumesElemAzureDisk struct {
	// Host Caching mode: None, Read Only, Read Write.
	CachingMode *string `json:"cachingMode,omitempty"`

	// The Name of the data disk in the blob storage
	DiskName string `json:"diskName"`

	// The URI the data disk in the blob storage
	DiskURI string `json:"diskURI"`

	// Filesystem type to mount. Must be a filesystem type supported by the host
	// operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4"
	// if unspecified.
	FsType *string `json:"fsType,omitempty"`

	// Expected values Shared: multiple blob disks per storage account  Dedicated:
	// single blob disk per storage account  Managed: azure managed data disk (only in
	// managed availability set). defaults to shared
	Kind *string `json:"kind,omitempty"`

	// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
	// in VolumeMounts.
	ReadOnly *bool `json:"readOnly,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemAzureDisk) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["diskName"]; !ok || v == nil {
		return fmt.Errorf("field diskName: required")
	}
	if v, ok := raw["diskURI"]; !ok || v == nil {
		return fmt.Errorf("field diskURI: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemAzureDisk
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemAzureDisk(plain)
	return nil
}

// AzureFile represents an Azure File Service mount on the host and bind mount to
// the pod.
type SubscriptionSpecConfigVolumesElemAzureFile struct {
	// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
	// in VolumeMounts.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// the name of secret that contains Azure Storage Account Name and Key
	SecretName string `json:"secretName"`

	// Share Name
	ShareName string `json:"shareName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemAzureFile) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["secretName"]; !ok || v == nil {
		return fmt.Errorf("field secretName: required")
	}
	if v, ok := raw["shareName"]; !ok || v == nil {
		return fmt.Errorf("field shareName: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemAzureFile
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemAzureFile(plain)
	return nil
}

// Optional: SecretRef is reference to the authentication secret for User, default
// is empty. More info:
// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
type SubscriptionSpecConfigVolumesElemCephfsSecretRef struct {
	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `json:"name,omitempty"`
}

// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
type SubscriptionSpecConfigVolumesElemCephfs struct {
	// Required: Monitors is a collection of Ceph monitors More info:
	// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	Monitors []string `json:"monitors"`

	// Optional: Used as the mounted root, rather than the full Ceph tree, default is
	// /
	Path *string `json:"path,omitempty"`

	// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly
	// setting in VolumeMounts. More info:
	// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	ReadOnly *bool `json:"readOnly,omitempty"`

	// Optional: SecretFile is the path to key ring for User, default is
	// /etc/ceph/user.secret More info:
	// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	SecretFile *string `json:"secretFile,omitempty"`

	// Optional: SecretRef is reference to the authentication secret for User, default
	// is empty. More info:
	// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	SecretRef *SubscriptionSpecConfigVolumesElemCephfsSecretRef `json:"secretRef,omitempty"`

	// Optional: User is the rados user name, default is admin More info:
	// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	User *string `json:"user,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemCephfs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["monitors"]; !ok || v == nil {
		return fmt.Errorf("field monitors: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemCephfs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemCephfs(plain)
	return nil
}

// Optional: points to a secret object containing parameters used to connect to
// OpenStack.
type SubscriptionSpecConfigVolumesElemCinderSecretRef struct {
	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `json:"name,omitempty"`
}

// Cinder represents a cinder volume attached and mounted on kubelets host
// machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
type SubscriptionSpecConfigVolumesElemCinder struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host
	// operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be
	// "ext4" if unspecified. More info:
	// https://examples.k8s.io/mysql-cinder-pd/README.md
	FsType *string `json:"fsType,omitempty"`

	// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly
	// setting in VolumeMounts. More info:
	// https://examples.k8s.io/mysql-cinder-pd/README.md
	ReadOnly *bool `json:"readOnly,omitempty"`

	// Optional: points to a secret object containing parameters used to connect to
	// OpenStack.
	SecretRef *SubscriptionSpecConfigVolumesElemCinderSecretRef `json:"secretRef,omitempty"`

	// volume id used to identify the volume in cinder. More info:
	// https://examples.k8s.io/mysql-cinder-pd/README.md
	VolumeID string `json:"volumeID"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemCinder) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["volumeID"]; !ok || v == nil {
		return fmt.Errorf("field volumeID: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemCinder
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemCinder(plain)
	return nil
}

// Maps a string key to a path within a volume.
type SubscriptionSpecConfigVolumesElemConfigMapItemsElem struct {
	// The key to project.
	Key string `json:"key"`

	// Optional: mode bits used to set permissions on this file. Must be an octal
	// value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts
	// both octal and decimal values, JSON requires decimal values for mode bits. If
	// not specified, the volume defaultMode will be used. This might be in conflict
	// with other options that affect the file mode, like fsGroup, and the result can
	// be other mode bits set.
	Mode *int `json:"mode,omitempty"`

	// The relative path of the file to map the key to. May not be an absolute path.
	// May not contain the path element '..'. May not start with the string '..'.
	Path string `json:"path"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemConfigMapItemsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemConfigMapItemsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemConfigMapItemsElem(plain)
	return nil
}

// ConfigMap represents a configMap that should populate this volume
type SubscriptionSpecConfigVolumesElemConfigMap struct {
	// Optional: mode bits used to set permissions on created files by default. Must
	// be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
	// YAML accepts both octal and decimal values, JSON requires decimal values for
	// mode bits. Defaults to 0644. Directories within the path are not affected by
	// this setting. This might be in conflict with other options that affect the file
	// mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode *int `json:"defaultMode,omitempty"`

	// If unspecified, each key-value pair in the Data field of the referenced
	// ConfigMap will be projected into the volume as a file whose name is the key and
	// content is the value. If specified, the listed keys will be projected into the
	// specified paths, and unlisted keys will not be present. If a key is specified
	// which is not present in the ConfigMap, the volume setup will error unless it is
	// marked optional. Paths must be relative and may not contain the '..' path or
	// start with '..'.
	Items []SubscriptionSpecConfigVolumesElemConfigMapItemsElem `json:"items,omitempty"`

	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `json:"name,omitempty"`

	// Specify whether the ConfigMap or its keys must be defined
	Optional *bool `json:"optional,omitempty"`
}

// NodePublishSecretRef is a reference to the secret object containing sensitive
// information to pass to the CSI driver to complete the CSI NodePublishVolume and
// NodeUnpublishVolume calls. This field is optional, and  may be empty if no
// secret is required. If the secret object contains more than one secret, all
// secret references are passed.
type SubscriptionSpecConfigVolumesElemCsiNodePublishSecretRef struct {
	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `json:"name,omitempty"`
}

// VolumeAttributes stores driver-specific properties that are passed to the CSI
// driver. Consult your driver's documentation for supported values.
// type SubscriptionSpecConfigVolumesElemCsiVolumeAttributes map[string]interface{}

// CSI (Container Storage Interface) represents ephemeral storage that is handled
// by certain external CSI drivers (Beta feature).
type SubscriptionSpecConfigVolumesElemCsi struct {
	// Driver is the name of the CSI driver that handles this volume. Consult with
	// your admin for the correct name as registered in the cluster.
	Driver string `json:"driver"`

	// Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty
	// value is passed to the associated CSI driver which will determine the default
	// filesystem to apply.
	FsType *string `json:"fsType,omitempty"`

	// NodePublishSecretRef is a reference to the secret object containing sensitive
	// information to pass to the CSI driver to complete the CSI NodePublishVolume and
	// NodeUnpublishVolume calls. This field is optional, and  may be empty if no
	// secret is required. If the secret object contains more than one secret, all
	// secret references are passed.
	NodePublishSecretRef *SubscriptionSpecConfigVolumesElemCsiNodePublishSecretRef `json:"nodePublishSecretRef,omitempty"`

	// Specifies a read-only configuration for the volume. Defaults to false
	// (read/write).
	ReadOnly *bool `json:"readOnly,omitempty"`

	// VolumeAttributes stores driver-specific properties that are passed to the CSI
	// driver. Consult your driver's documentation for supported values.
	VolumeAttributes *apiextensions.JSON `json:"volumeAttributes,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemCsi) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["driver"]; !ok || v == nil {
		return fmt.Errorf("field driver: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemCsi
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemCsi(plain)
	return nil
}

// Required: Selects a field of the pod: only annotations, labels, name and
// namespace are supported.
type SubscriptionSpecConfigVolumesElemDownwardAPIItemsElemFieldRef struct {
	// Version of the schema the FieldPath is written in terms of, defaults to "v1".
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Path of the field to select in the specified API version.
	FieldPath string `json:"fieldPath"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemDownwardAPIItemsElemFieldRef) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["fieldPath"]; !ok || v == nil {
		return fmt.Errorf("field fieldPath: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemDownwardAPIItemsElemFieldRef
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemDownwardAPIItemsElemFieldRef(plain)
	return nil
}

// Selects a resource of the container: only resources limits and requests
// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently
// supported.
type SubscriptionSpecConfigVolumesElemDownwardAPIItemsElemResourceFieldRef struct {
	// Container name: required for volumes, optional for env vars
	ContainerName *string `json:"containerName,omitempty"`

	// Specifies the output format of the exposed resources, defaults to "1"
	Divisor *apiextensions.JSON `json:"divisor,omitempty"`

	// Required: resource to select
	Resource string `json:"resource"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemDownwardAPIItemsElemResourceFieldRef) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["resource"]; !ok || v == nil {
		return fmt.Errorf("field resource: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemDownwardAPIItemsElemResourceFieldRef
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemDownwardAPIItemsElemResourceFieldRef(plain)
	return nil
}

// DownwardAPIVolumeFile represents information to create the file containing the
// pod field
type SubscriptionSpecConfigVolumesElemDownwardAPIItemsElem struct {
	// Required: Selects a field of the pod: only annotations, labels, name and
	// namespace are supported.
	FieldRef *SubscriptionSpecConfigVolumesElemDownwardAPIItemsElemFieldRef `json:"fieldRef,omitempty"`

	// Optional: mode bits used to set permissions on this file, must be an octal
	// value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts
	// both octal and decimal values, JSON requires decimal values for mode bits. If
	// not specified, the volume defaultMode will be used. This might be in conflict
	// with other options that affect the file mode, like fsGroup, and the result can
	// be other mode bits set.
	Mode *int `json:"mode,omitempty"`

	// Required: Path is  the relative path name of the file to be created. Must not
	// be absolute or contain the '..' path. Must be utf-8 encoded. The first item of
	// the relative path must not start with '..'
	Path string `json:"path"`

	// Selects a resource of the container: only resources limits and requests
	// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently
	// supported.
	ResourceFieldRef *SubscriptionSpecConfigVolumesElemDownwardAPIItemsElemResourceFieldRef `json:"resourceFieldRef,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemDownwardAPIItemsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemDownwardAPIItemsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemDownwardAPIItemsElem(plain)
	return nil
}

// DownwardAPI represents downward API about the pod that should populate this
// volume
type SubscriptionSpecConfigVolumesElemDownwardAPI struct {
	// Optional: mode bits to use on created files by default. Must be a Optional:
	// mode bits used to set permissions on created files by default. Must be an octal
	// value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts
	// both octal and decimal values, JSON requires decimal values for mode bits.
	// Defaults to 0644. Directories within the path are not affected by this setting.
	// This might be in conflict with other options that affect the file mode, like
	// fsGroup, and the result can be other mode bits set.
	DefaultMode *int `json:"defaultMode,omitempty"`

	// Items is a list of downward API volume file
	Items []SubscriptionSpecConfigVolumesElemDownwardAPIItemsElem `json:"items,omitempty"`
}

// EmptyDir represents a temporary directory that shares a pod's lifetime. More
// info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
type SubscriptionSpecConfigVolumesElemEmptyDir struct {
	// What type of storage medium should back this directory. The default is "" which
	// means to use the node's default medium. Must be an empty string (default) or
	// Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
	Medium *string `json:"medium,omitempty"`

	// Total amount of local storage required for this EmptyDir volume. The size limit
	// is also applicable for memory medium. The maximum usage on memory medium
	// EmptyDir would be the minimum value between the SizeLimit specified here and
	// the sum of memory limits of all containers in a pod. The default is nil which
	// means that the limit is undefined. More info:
	// http://kubernetes.io/docs/user-guide/volumes#emptydir
	SizeLimit *apiextensions.JSON `json:"sizeLimit,omitempty"`
}

// May contain labels and annotations that will be copied into the PVC when
// creating it. No other fields are allowed and will be rejected during validation.
// type SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateMetadata map[string]interface{}

// This field can be used to specify either: * An existing VolumeSnapshot object
// (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC
// (PersistentVolumeClaim) If the provisioner or an external controller can support
// the specified data source, it will create a new volume based on the contents of
// the specified data source. If the AnyVolumeDataSource feature gate is enabled,
// this field will always have the same contents as the DataSourceRef field.
type SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecDataSource struct {
	// APIGroup is the group for the resource being referenced. If APIGroup is not
	// specified, the specified Kind must be in the core API group. For any other
	// third-party types, APIGroup is required.
	ApiGroup *string `json:"apiGroup,omitempty"`

	// Kind is the type of resource being referenced
	Kind string `json:"kind"`

	// Name is the name of resource being referenced
	Name string `json:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecDataSource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecDataSource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecDataSource(plain)
	return nil
}

// Specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any local object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object. When this field is specified,
// volume binding will only succeed if the type of the specified object matches
// some installed volume populator or dynamic provisioner. This field will replace
// the functionality of the DataSource field and as such if both fields are
// non-empty, they must have the same value. For backwards compatibility, both
// fields (DataSource and DataSourceRef) will be set to the same value
// automatically if one of them is empty and the other is non-empty. There are two
// important differences between DataSource and DataSourceRef: * While DataSource
// only allows two specific types of objects, DataSourceRef   allows any non-core
// object, as well as PersistentVolumeClaim objects. * While DataSource ignores
// disallowed values (dropping them), DataSourceRef   preserves all values, and
// generates an error if a disallowed value is   specified. (Alpha) Using this
// field requires the AnyVolumeDataSource feature gate to be enabled.
type SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecDataSourceRef struct {
	// APIGroup is the group for the resource being referenced. If APIGroup is not
	// specified, the specified Kind must be in the core API group. For any other
	// third-party types, APIGroup is required.
	ApiGroup *string `json:"apiGroup,omitempty"`

	// Kind is the type of resource being referenced
	Kind string `json:"kind"`

	// Name is the name of resource being referenced
	Name string `json:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecDataSourceRef) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecDataSourceRef
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecDataSourceRef(plain)
	return nil
}

// Limits describes the maximum amount of compute resources allowed. More info:
// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
// type SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecResourcesLimits map[string]interface{}

// Requests describes the minimum amount of compute resources required. If Requests
// is omitted for a container, it defaults to Limits if that is explicitly
// specified, otherwise to an implementation-defined value. More info:
// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
// type SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecResourcesRequests map[string]interface{}

// Resources represents the minimum resources the volume should have. More info:
// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecResources struct {
	// Limits describes the maximum amount of compute resources allowed. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Limits *apiextensions.JSON `json:"limits,omitempty"`

	// Requests describes the minimum amount of compute resources required. If
	// Requests is omitted for a container, it defaults to Limits if that is
	// explicitly specified, otherwise to an implementation-defined value. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Requests *apiextensions.JSON `json:"requests,omitempty"`
}

// A label selector requirement is a selector that contains values, a key, and an
// operator that relates the key and values.
type SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecSelectorMatchExpressionsElem struct {
	// key is the label key that the selector applies to.
	Key string `json:"key"`

	// operator represents a key's relationship to a set of values. Valid operators
	// are In, NotIn, Exists and DoesNotExist.
	Operator string `json:"operator"`

	// values is an array of string values. If the operator is In or NotIn, the values
	// array must be non-empty. If the operator is Exists or DoesNotExist, the values
	// array must be empty. This array is replaced during a strategic merge patch.
	Values []string `json:"values,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecSelectorMatchExpressionsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key: required")
	}
	if v, ok := raw["operator"]; !ok || v == nil {
		return fmt.Errorf("field operator: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecSelectorMatchExpressionsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecSelectorMatchExpressionsElem(plain)
	return nil
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the
// matchLabels map is equivalent to an element of matchExpressions, whose key field
// is "key", the operator is "In", and the values array contains only "value". The
// requirements are ANDed.
// type SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecSelectorMatchLabels map[string]interface{}

// A label query over volumes to consider for binding.
type SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are
	// ANDed.
	MatchExpressions []SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// matchLabels is a map of {key,value} pairs. A single {key,value} in the
	// matchLabels map is equivalent to an element of matchExpressions, whose key
	// field is "key", the operator is "In", and the values array contains only
	// "value". The requirements are ANDed.
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

// The specification for the PersistentVolumeClaim. The entire content is copied
// unchanged into the PVC that gets created from this template. The same fields as
// in a PersistentVolumeClaim are also valid here.
type SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpec struct {
	// AccessModes contains the desired access modes the volume should have. More
	// info:
	// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes []string `json:"accessModes,omitempty"`

	// This field can be used to specify either: * An existing VolumeSnapshot object
	// (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC
	// (PersistentVolumeClaim) If the provisioner or an external controller can
	// support the specified data source, it will create a new volume based on the
	// contents of the specified data source. If the AnyVolumeDataSource feature gate
	// is enabled, this field will always have the same contents as the DataSourceRef
	// field.
	DataSource *SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecDataSource `json:"dataSource,omitempty"`

	// Specifies the object from which to populate the volume with data, if a
	// non-empty volume is desired. This may be any local object from a non-empty API
	// group (non core object) or a PersistentVolumeClaim object. When this field is
	// specified, volume binding will only succeed if the type of the specified object
	// matches some installed volume populator or dynamic provisioner. This field will
	// replace the functionality of the DataSource field and as such if both fields
	// are non-empty, they must have the same value. For backwards compatibility, both
	// fields (DataSource and DataSourceRef) will be set to the same value
	// automatically if one of them is empty and the other is non-empty. There are two
	// important differences between DataSource and DataSourceRef: * While DataSource
	// only allows two specific types of objects, DataSourceRef   allows any non-core
	// object, as well as PersistentVolumeClaim objects. * While DataSource ignores
	// disallowed values (dropping them), DataSourceRef   preserves all values, and
	// generates an error if a disallowed value is   specified. (Alpha) Using this
	// field requires the AnyVolumeDataSource feature gate to be enabled.
	DataSourceRef *SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecDataSourceRef `json:"dataSourceRef,omitempty"`

	// Resources represents the minimum resources the volume should have. More info:
	// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
	Resources *SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecResources `json:"resources,omitempty"`

	// A label query over volumes to consider for binding.
	Selector *SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpecSelector `json:"selector,omitempty"`

	// Name of the StorageClass required by the claim. More info:
	// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
	StorageClassName *string `json:"storageClassName,omitempty"`

	// volumeMode defines what type of volume is required by the claim. Value of
	// Filesystem is implied when not included in claim spec.
	VolumeMode *string `json:"volumeMode,omitempty"`

	// VolumeName is the binding reference to the PersistentVolume backing this claim.
	VolumeName *string `json:"volumeName,omitempty"`
}

// Will be used to create a stand-alone PVC to provision the volume. The pod in
// which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e.
// the PVC will be deleted together with the pod.  The name of the PVC will be
// `<pod name>-<volume name>` where `<volume name>` is the name from the
// `PodSpec.Volumes` array entry. Pod validation will reject the pod if the
// concatenated name is not valid for a PVC (for example, too long).
//
//	An existing PVC with that name that is not owned by the pod will *not* be used
//
// for the pod to avoid using an unrelated volume by mistake. Starting the pod is
// then blocked until the unrelated PVC is removed. If such a pre-created PVC is
// meant to be used by the pod, the PVC has to updated with an owner reference to
// the pod once the pod exists. Normally this should not be necessary, but it may
// be useful when manually reconstructing a broken cluster.
//
//	This field is read-only and no changes will be made by Kubernetes to the PVC
//
// after it has been created.
//
//	Required, must not be nil.
type SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplate struct {
	// May contain labels and annotations that will be copied into the PVC when
	// creating it. No other fields are allowed and will be rejected during
	// validation.
	Metadata *apiextensions.JSON `json:"metadata,omitempty"`

	// The specification for the PersistentVolumeClaim. The entire content is copied
	// unchanged into the PVC that gets created from this template. The same fields as
	// in a PersistentVolumeClaim are also valid here.
	Spec SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplateSpec `json:"spec"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["spec"]; !ok || v == nil {
		return fmt.Errorf("field spec: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplate(plain)
	return nil
}

// Ephemeral represents a volume that is handled by a cluster storage driver. The
// volume's lifecycle is tied to the pod that defines it - it will be created
// before the pod starts, and deleted when the pod is removed.
//
//	Use this if: a) the volume is only needed while the pod runs, b) features of
//
// normal volumes like restoring from snapshot or capacity    tracking are needed,
// c) the storage driver is specified through a storage class, and d) the storage
// driver supports dynamic volume provisioning through    a PersistentVolumeClaim
// (see EphemeralVolumeSource for more    information on the connection between
// this volume type    and PersistentVolumeClaim).
//
//	Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that
//
// persist for longer than the lifecycle of an individual pod.
//
//	Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
//
// be used that way - see the documentation of the driver for more information.
//
//	A pod can use both types of ephemeral volumes and persistent volumes at the
//
// same time.
//
//	This is a beta feature and only available when the GenericEphemeralVolume
//
// feature gate is enabled.
type SubscriptionSpecConfigVolumesElemEphemeral struct {
	// Will be used to create a stand-alone PVC to provision the volume. The pod in
	// which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e.
	// the PVC will be deleted together with the pod.  The name of the PVC will be
	// `<pod name>-<volume name>` where `<volume name>` is the name from the
	// `PodSpec.Volumes` array entry. Pod validation will reject the pod if the
	// concatenated name is not valid for a PVC (for example, too long).
	//  An existing PVC with that name that is not owned by the pod will *not* be used
	// for the pod to avoid using an unrelated volume by mistake. Starting the pod is
	// then blocked until the unrelated PVC is removed. If such a pre-created PVC is
	// meant to be used by the pod, the PVC has to updated with an owner reference to
	// the pod once the pod exists. Normally this should not be necessary, but it may
	// be useful when manually reconstructing a broken cluster.
	//  This field is read-only and no changes will be made by Kubernetes to the PVC
	// after it has been created.
	//  Required, must not be nil.
	VolumeClaimTemplate *SubscriptionSpecConfigVolumesElemEphemeralVolumeClaimTemplate `json:"volumeClaimTemplate,omitempty"`
}

// FC represents a Fibre Channel resource that is attached to a kubelet's host
// machine and then exposed to the pod.
type SubscriptionSpecConfigVolumesElemFc struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host
	// operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4"
	// if unspecified. TODO: how do we prevent errors in the filesystem from
	// compromising the machine
	FsType *string `json:"fsType,omitempty"`

	// Optional: FC target lun number
	Lun *int `json:"lun,omitempty"`

	// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly
	// setting in VolumeMounts.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// Optional: FC target worldwide names (WWNs)
	TargetWWNs []string `json:"targetWWNs,omitempty"`

	// Optional: FC volume world wide identifiers (wwids) Either wwids or combination
	// of targetWWNs and lun must be set, but not both simultaneously.
	Wwids []string `json:"wwids,omitempty"`
}

// Optional: Extra command options if any.
// type SubscriptionSpecConfigVolumesElemFlexVolumeOptions map[string]interface{}

// Requests describes the minimum amount of compute resources required. If Requests
// is omitted for a container, it defaults to Limits if that is explicitly
// specified, otherwise to an implementation-defined value. More info:
// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
// type SubscriptionSpecConfigResourcesRequests map[string]interface{}

// FlexVolume represents a generic volume resource that is provisioned/attached
// using an exec based plugin.
type SubscriptionSpecConfigVolumesElemFlexVolume struct {
	// Driver is the name of the driver to use for this volume.
	Driver string `json:"driver"`

	// Filesystem type to mount. Must be a filesystem type supported by the host
	// operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on
	// FlexVolume script.
	FsType *string `json:"fsType,omitempty"`

	// Optional: Extra command options if any.
	Options *apiextensions.JSON `json:"options,omitempty"`

	// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly
	// setting in VolumeMounts.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// Optional: SecretRef is reference to the secret object containing sensitive
	// information to pass to the plugin scripts. This may be empty if no secret
	// object is specified. If the secret object contains more than one secret, all
	// secrets are passed to the plugin scripts.
	SecretRef *SubscriptionSpecConfigVolumesElemFlexVolumeSecretRef `json:"secretRef,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemFlexVolume) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["driver"]; !ok || v == nil {
		return fmt.Errorf("field driver: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemFlexVolume
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemFlexVolume(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionStatus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["lastUpdated"]; !ok || v == nil {
		return fmt.Errorf("field lastUpdated: required")
	}
	type Plain SubscriptionStatus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionStatus(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionStatusInstallplan) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["apiVersion"]; !ok || v == nil {
		return fmt.Errorf("field apiVersion: required")
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["uuid"]; !ok || v == nil {
		return fmt.Errorf("field uuid: required")
	}
	type Plain SubscriptionStatusInstallplan
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionStatusInstallplan(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemGcePersistentDisk) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pdName"]; !ok || v == nil {
		return fmt.Errorf("field pdName: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemGcePersistentDisk
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemGcePersistentDisk(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionStatusConditionsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["status"]; !ok || v == nil {
		return fmt.Errorf("field status: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain SubscriptionStatusConditionsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionStatusConditionsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemGitRepo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["repository"]; !ok || v == nil {
		return fmt.Errorf("field repository: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemGitRepo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemGitRepo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionStatusCatalogHealthElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["catalogSourceRef"]; !ok || v == nil {
		return fmt.Errorf("field catalogSourceRef: required")
	}
	if v, ok := raw["healthy"]; !ok || v == nil {
		return fmt.Errorf("field healthy: required")
	}
	if v, ok := raw["lastUpdated"]; !ok || v == nil {
		return fmt.Errorf("field lastUpdated: required")
	}
	type Plain SubscriptionStatusCatalogHealthElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionStatusCatalogHealthElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemGlusterfs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["endpoints"]; !ok || v == nil {
		return fmt.Errorf("field endpoints: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemGlusterfs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemGlusterfs(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpec) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source: required")
	}
	if v, ok := raw["sourceNamespace"]; !ok || v == nil {
		return fmt.Errorf("field sourceNamespace: required")
	}
	type Plain SubscriptionSpec
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpec(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemHostPath) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemHostPath
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemHostPath(plain)
	return nil
}

// SubscriptionSpec defines an Application that can be installed
type SubscriptionSpec struct {
	// Channel corresponds to the JSON schema field "channel".
	Channel *string `json:"channel,omitempty"`

	// SubscriptionConfig contains configuration specified for a subscription.
	Config *SubscriptionSpecConfig `json:"config,omitempty"`

	// Approval is the user approval policy for an InstallPlan. It must be one of
	// "Automatic" or "Manual".
	InstallPlanApproval *string `json:"installPlanApproval,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name"`

	// Source corresponds to the JSON schema field "source".
	Source string `json:"source"`

	// SourceNamespace corresponds to the JSON schema field "sourceNamespace".
	SourceNamespace string `json:"sourceNamespace"`

	// StartingCSV corresponds to the JSON schema field "startingCSV".
	StartingCSV *string `json:"startingCSV,omitempty"`
}

// SubscriptionConfig contains configuration specified for a subscription.
type SubscriptionSpecConfig struct {
	// Env is a list of environment variables to set in the container. Cannot be
	// updated.
	Env []SubscriptionSpecConfigEnvElem `json:"env,omitempty"`

	// EnvFrom is a list of sources to populate environment variables in the
	// container. The keys defined within a source must be a C_IDENTIFIER. All invalid
	// keys will be reported as an event when the container is starting. When a key
	// exists in multiple sources, the value associated with the last source will take
	// precedence. Values defined by an Env with a duplicate key will take precedence.
	// Immutable.
	EnvFrom []SubscriptionSpecConfigEnvFromElem `json:"envFrom,omitempty"`

	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that
	// node. More info:
	// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	NodeSelector *apiextensions.JSON `json:"nodeSelector,omitempty"`

	// Resources represents compute resources required by this container. Immutable.
	// More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Resources *SubscriptionSpecConfigResources `json:"resources,omitempty"`

	// Selector is the label selector for pods to be configured. Existing ReplicaSets
	// whose pods are selected by this will be the ones affected by this deployment.
	// It must match the pod template's labels.
	Selector *SubscriptionSpecConfigSelector `json:"selector,omitempty"`

	// Tolerations are the pod's tolerations.
	Tolerations []SubscriptionSpecConfigTolerationsElem `json:"tolerations,omitempty"`

	// List of VolumeMounts to set in the container.
	VolumeMounts []SubscriptionSpecConfigVolumeMountsElem `json:"volumeMounts,omitempty"`

	// List of Volumes to set in the podSpec.
	Volumes []SubscriptionSpecConfigVolumesElem `json:"volumes,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemIscsi) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["iqn"]; !ok || v == nil {
		return fmt.Errorf("field iqn: required")
	}
	if v, ok := raw["lun"]; !ok || v == nil {
		return fmt.Errorf("field lun: required")
	}
	if v, ok := raw["targetPortal"]; !ok || v == nil {
		return fmt.Errorf("field targetPortal: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemIscsi
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemIscsi(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain SubscriptionSpecConfigVolumesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemNfs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path: required")
	}
	if v, ok := raw["server"]; !ok || v == nil {
		return fmt.Errorf("field server: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemNfs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemNfs(plain)
	return nil
}

// Volume represents a named volume in a pod that may be accessed by any container
// in the pod.
type SubscriptionSpecConfigVolumesElem struct {
	// AWSElasticBlockStore represents an AWS Disk resource that is attached to a
	// kubelet's host machine and then exposed to the pod. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
	AwsElasticBlockStore *SubscriptionSpecConfigVolumesElemAwsElasticBlockStore `json:"awsElasticBlockStore,omitempty"`

	// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the
	// pod.
	AzureDisk *SubscriptionSpecConfigVolumesElemAzureDisk `json:"azureDisk,omitempty"`

	// AzureFile represents an Azure File Service mount on the host and bind mount to
	// the pod.
	AzureFile *SubscriptionSpecConfigVolumesElemAzureFile `json:"azureFile,omitempty"`

	// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
	Cephfs *SubscriptionSpecConfigVolumesElemCephfs `json:"cephfs,omitempty"`

	// Cinder represents a cinder volume attached and mounted on kubelets host
	// machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
	Cinder *SubscriptionSpecConfigVolumesElemCinder `json:"cinder,omitempty"`

	// ConfigMap represents a configMap that should populate this volume
	ConfigMap *SubscriptionSpecConfigVolumesElemConfigMap `json:"configMap,omitempty"`

	// CSI (Container Storage Interface) represents ephemeral storage that is handled
	// by certain external CSI drivers (Beta feature).
	Csi *SubscriptionSpecConfigVolumesElemCsi `json:"csi,omitempty"`

	// DownwardAPI represents downward API about the pod that should populate this
	// volume
	DownwardAPI *SubscriptionSpecConfigVolumesElemDownwardAPI `json:"downwardAPI,omitempty"`

	// EmptyDir represents a temporary directory that shares a pod's lifetime. More
	// info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
	EmptyDir *SubscriptionSpecConfigVolumesElemEmptyDir `json:"emptyDir,omitempty"`

	// Ephemeral represents a volume that is handled by a cluster storage driver. The
	// volume's lifecycle is tied to the pod that defines it - it will be created
	// before the pod starts, and deleted when the pod is removed.
	//  Use this if: a) the volume is only needed while the pod runs, b) features of
	// normal volumes like restoring from snapshot or capacity    tracking are needed,
	// c) the storage driver is specified through a storage class, and d) the storage
	// driver supports dynamic volume provisioning through    a PersistentVolumeClaim
	// (see EphemeralVolumeSource for more    information on the connection between
	// this volume type    and PersistentVolumeClaim).
	//  Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that
	// persist for longer than the lifecycle of an individual pod.
	//  Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
	// be used that way - see the documentation of the driver for more information.
	//  A pod can use both types of ephemeral volumes and persistent volumes at the
	// same time.
	//  This is a beta feature and only available when the GenericEphemeralVolume
	// feature gate is enabled.
	Ephemeral *SubscriptionSpecConfigVolumesElemEphemeral `json:"ephemeral,omitempty"`

	// FC represents a Fibre Channel resource that is attached to a kubelet's host
	// machine and then exposed to the pod.
	Fc *SubscriptionSpecConfigVolumesElemFc `json:"fc,omitempty"`

	// FlexVolume represents a generic volume resource that is provisioned/attached
	// using an exec based plugin.
	FlexVolume *SubscriptionSpecConfigVolumesElemFlexVolume `json:"flexVolume,omitempty"`

	// Flocker represents a Flocker volume attached to a kubelet's host machine. This
	// depends on the Flocker control service being running
	Flocker *SubscriptionSpecConfigVolumesElemFlocker `json:"flocker,omitempty"`

	// GCEPersistentDisk represents a GCE Disk resource that is attached to a
	// kubelet's host machine and then exposed to the pod. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	GcePersistentDisk *SubscriptionSpecConfigVolumesElemGcePersistentDisk `json:"gcePersistentDisk,omitempty"`

	// GitRepo represents a git repository at a particular revision. DEPRECATED:
	// GitRepo is deprecated. To provision a container with a git repo, mount an
	// EmptyDir into an InitContainer that clones the repo using git, then mount the
	// EmptyDir into the Pod's container.
	GitRepo *SubscriptionSpecConfigVolumesElemGitRepo `json:"gitRepo,omitempty"`

	// Glusterfs represents a Glusterfs mount on the host that shares a pod's
	// lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
	Glusterfs *SubscriptionSpecConfigVolumesElemGlusterfs `json:"glusterfs,omitempty"`

	// HostPath represents a pre-existing file or directory on the host machine that
	// is directly exposed to the container. This is generally used for system agents
	// or other privileged things that are allowed to see the host machine. Most
	// containers will NOT need this. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl)
	// We need to restrict who can use host directory mounts and who can/can not mount
	// host directories as read/write.
	HostPath *SubscriptionSpecConfigVolumesElemHostPath `json:"hostPath,omitempty"`

	// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host
	// machine and then exposed to the pod. More info:
	// https://examples.k8s.io/volumes/iscsi/README.md
	Iscsi *SubscriptionSpecConfigVolumesElemIscsi `json:"iscsi,omitempty"`

	// Volume's name. Must be a DNS_LABEL and unique within the pod. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `json:"name"`

	// NFS represents an NFS mount on the host that shares a pod's lifetime More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#nfs
	Nfs *SubscriptionSpecConfigVolumesElemNfs `json:"nfs,omitempty"`

	// PersistentVolumeClaimVolumeSource represents a reference to a
	// PersistentVolumeClaim in the same namespace. More info:
	// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	PersistentVolumeClaim *SubscriptionSpecConfigVolumesElemPersistentVolumeClaim `json:"persistentVolumeClaim,omitempty"`

	// PhotonPersistentDisk represents a PhotonController persistent disk attached and
	// mounted on kubelets host machine
	PhotonPersistentDisk *SubscriptionSpecConfigVolumesElemPhotonPersistentDisk `json:"photonPersistentDisk,omitempty"`

	// PortworxVolume represents a portworx volume attached and mounted on kubelets
	// host machine
	PortworxVolume *SubscriptionSpecConfigVolumesElemPortworxVolume `json:"portworxVolume,omitempty"`

	// Items for all in one resources secrets, configmaps, and downward API
	Projected *SubscriptionSpecConfigVolumesElemProjected `json:"projected,omitempty"`

	// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
	Quobyte *SubscriptionSpecConfigVolumesElemQuobyte `json:"quobyte,omitempty"`

	// RBD represents a Rados Block Device mount on the host that shares a pod's
	// lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
	Rbd *SubscriptionSpecConfigVolumesElemRbd `json:"rbd,omitempty"`

	// ScaleIO represents a ScaleIO persistent volume attached and mounted on
	// Kubernetes nodes.
	ScaleIO *SubscriptionSpecConfigVolumesElemScaleIO `json:"scaleIO,omitempty"`

	// Secret represents a secret that should populate this volume. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#secret
	Secret *SubscriptionSpecConfigVolumesElemSecret `json:"secret,omitempty"`

	// StorageOS represents a StorageOS volume attached and mounted on Kubernetes
	// nodes.
	Storageos *SubscriptionSpecConfigVolumesElemStorageos `json:"storageos,omitempty"`

	// VsphereVolume represents a vSphere volume attached and mounted on kubelets host
	// machine
	VsphereVolume *SubscriptionSpecConfigVolumesElemVsphereVolume `json:"vsphereVolume,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemPersistentVolumeClaim) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["claimName"]; !ok || v == nil {
		return fmt.Errorf("field claimName: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemPersistentVolumeClaim
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemPersistentVolumeClaim(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemVsphereVolume) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["volumePath"]; !ok || v == nil {
		return fmt.Errorf("field volumePath: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemVsphereVolume
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemVsphereVolume(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemPhotonPersistentDisk) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pdID"]; !ok || v == nil {
		return fmt.Errorf("field pdID: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemPhotonPersistentDisk
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemPhotonPersistentDisk(plain)
	return nil
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
type Subscription struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	// SubscriptionSpec defines an Application that can be installed
	Spec *SubscriptionSpec `json:"spec,omitempty"`

	// Status corresponds to the JSON schema field "status".
	Status *SubscriptionStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true
type SubscriptionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`

	// A list of Kafka objects.
	Items []Subscription `json:"items,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemPortworxVolume) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["volumeID"]; !ok || v == nil {
		return fmt.Errorf("field volumeID: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemPortworxVolume
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemPortworxVolume(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemSecretItemsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemSecretItemsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemSecretItemsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemProjectedSourcesElemConfigMapItemsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemProjectedSourcesElemConfigMapItemsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemProjectedSourcesElemConfigMapItemsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemScaleIO) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["gateway"]; !ok || v == nil {
		return fmt.Errorf("field gateway: required")
	}
	if v, ok := raw["secretRef"]; !ok || v == nil {
		return fmt.Errorf("field secretRef: required")
	}
	if v, ok := raw["system"]; !ok || v == nil {
		return fmt.Errorf("field system: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemScaleIO
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemScaleIO(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemRbd) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["image"]; !ok || v == nil {
		return fmt.Errorf("field image: required")
	}
	if v, ok := raw["monitors"]; !ok || v == nil {
		return fmt.Errorf("field monitors: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemRbd
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemRbd(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPIItemsElemFieldRef) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["fieldPath"]; !ok || v == nil {
		return fmt.Errorf("field fieldPath: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPIItemsElemFieldRef
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPIItemsElemFieldRef(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemQuobyte) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["registry"]; !ok || v == nil {
		return fmt.Errorf("field registry: required")
	}
	if v, ok := raw["volume"]; !ok || v == nil {
		return fmt.Errorf("field volume: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemQuobyte
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemQuobyte(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPIItemsElemResourceFieldRef) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["resource"]; !ok || v == nil {
		return fmt.Errorf("field resource: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPIItemsElemResourceFieldRef
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPIItemsElemResourceFieldRef(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemProjectedSourcesElemServiceAccountToken) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemProjectedSourcesElemServiceAccountToken
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemProjectedSourcesElemServiceAccountToken(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPIItemsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path: required")
	}
	type Plain SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPIItemsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPIItemsElem(plain)
	return nil
}

// Optional: SecretRef is reference to the secret object containing sensitive
// information to pass to the plugin scripts. This may be empty if no secret object
// is specified. If the secret object contains more than one secret, all secrets
// are passed to the plugin scripts.
type SubscriptionSpecConfigVolumesElemFlexVolumeSecretRef struct {
	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `json:"name,omitempty"`
}

// Flocker represents a Flocker volume attached to a kubelet's host machine. This
// depends on the Flocker control service being running
type SubscriptionSpecConfigVolumesElemFlocker struct {
	// Name of the dataset stored as metadata -> name on the dataset for Flocker
	// should be considered as deprecated
	DatasetName *string `json:"datasetName,omitempty"`

	// UUID of the dataset. This is unique identifier of a Flocker dataset
	DatasetUUID *string `json:"datasetUUID,omitempty"`
}

// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's
// host machine and then exposed to the pod. More info:
// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
type SubscriptionSpecConfigVolumesElemGcePersistentDisk struct {
	// Filesystem type of the volume that you want to mount. Tip: Ensure that the
	// filesystem type is supported by the host operating system. Examples: "ext4",
	// "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how
	// do we prevent errors in the filesystem from compromising the machine
	FsType *string `json:"fsType,omitempty"`

	// The partition in the volume that you want to mount. If omitted, the default is
	// to mount by volume name. Examples: For volume /dev/sda1, you specify the
	// partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you
	// can leave the property empty). More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	Partition *int `json:"partition,omitempty"`

	// Unique name of the PD resource in GCE. Used to identify the disk in GCE. More
	// info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	PdName string `json:"pdName"`

	// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to
	// false. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	ReadOnly *bool `json:"readOnly,omitempty"`
}

// GitRepo represents a git repository at a particular revision. DEPRECATED:
// GitRepo is deprecated. To provision a container with a git repo, mount an
// EmptyDir into an InitContainer that clones the repo using git, then mount the
// EmptyDir into the Pod's container.
type SubscriptionSpecConfigVolumesElemGitRepo struct {
	// Target directory name. Must not contain or start with '..'.  If '.' is
	// supplied, the volume directory will be the git repository.  Otherwise, if
	// specified, the volume will contain the git repository in the subdirectory with
	// the given name.
	Directory *string `json:"directory,omitempty"`

	// Repository URL
	Repository string `json:"repository"`

	// Commit hash for the specified revision.
	Revision *string `json:"revision,omitempty"`
}

// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
// More info: https://examples.k8s.io/volumes/glusterfs/README.md
type SubscriptionSpecConfigVolumesElemGlusterfs struct {
	// EndpointsName is the endpoint name that details Glusterfs topology. More info:
	// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
	Endpoints string `json:"endpoints"`

	// Path is the Glusterfs volume path. More info:
	// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
	Path string `json:"path"`

	// ReadOnly here will force the Glusterfs volume to be mounted with read-only
	// permissions. Defaults to false. More info:
	// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
	ReadOnly *bool `json:"readOnly,omitempty"`
}

// HostPath represents a pre-existing file or directory on the host machine that
// is directly exposed to the container. This is generally used for system agents or
// other privileged things that are allowed to see the host machine. Most
// containers will NOT need this. More info:
// https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl)
// We need to restrict who can use host directory mounts and who can/can not mount
// host directories as read/write.
type SubscriptionSpecConfigVolumesElemHostPath struct {
	// Path of the directory on the host. If the path is a symlink, it will follow the
	// link to the real path. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
	Path string `json:"path"`

	// Type for HostPath Volume Defaults to "" More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
	Type *string `json:"type,omitempty"`
}

// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host
// machine and then exposed to the pod. More info:
// https://examples.k8s.io/volumes/iscsi/README.md
type SubscriptionSpecConfigVolumesElemIscsi struct {
	// whether support iSCSI Discovery CHAP authentication
	ChapAuthDiscovery *bool `json:"chapAuthDiscovery,omitempty"`

	// whether support iSCSI Session CHAP authentication
	ChapAuthSession *bool `json:"chapAuthSession,omitempty"`

	// Filesystem type of the volume that you want to mount. Tip: Ensure that the
	// filesystem type is supported by the host operating system. Examples: "ext4",
	// "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we
	// prevent errors in the filesystem from compromising the machine
	FsType *string `json:"fsType,omitempty"`

	// Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface
	// simultaneously, new iSCSI interface <target portal>:<volume name> will be
	// created for the connection.
	InitiatorName *string `json:"initiatorName,omitempty"`

	// Target iSCSI Qualified Name.
	Iqn string `json:"iqn"`

	// iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
	IscsiInterface *string `json:"iscsiInterface,omitempty"`

	// iSCSI Target Lun number.
	Lun int `json:"lun"`

	// iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the
	// port is other than default (typically TCP ports 860 and 3260).
	Portals []string `json:"portals,omitempty"`

	// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to
	// false.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// CHAP Secret for iSCSI target and initiator authentication
	SecretRef *SubscriptionSpecConfigVolumesElemIscsiSecretRef `json:"secretRef,omitempty"`

	// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is
	// other than default (typically TCP ports 860 and 3260).
	TargetPortal string `json:"targetPortal"`
}

// CHAP Secret for iSCSI target and initiator authentication
type SubscriptionSpecConfigVolumesElemIscsiSecretRef struct {
	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `json:"name,omitempty"`
}

// NFS represents an NFS mount on the host that shares a pod's lifetime More info:
// https://kubernetes.io/docs/concepts/storage/volumes#nfs
type SubscriptionSpecConfigVolumesElemNfs struct {
	// Path that is exported by the NFS server. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#nfs
	Path string `json:"path"`

	// ReadOnly here will force the NFS export to be mounted with read-only
	// permissions. Defaults to false. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#nfs
	ReadOnly *bool `json:"readOnly,omitempty"`

	// Server is the hostname or IP address of the NFS server. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#nfs
	Server string `json:"server"`
}

// PersistentVolumeClaimVolumeSource represents a reference to a
// PersistentVolumeClaim in the same namespace. More info:
// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type SubscriptionSpecConfigVolumesElemPersistentVolumeClaim struct {
	// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the
	// pod using this volume. More info:
	// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	ClaimName string `json:"claimName"`

	// Will force the ReadOnly setting in VolumeMounts. Default false.
	ReadOnly *bool `json:"readOnly,omitempty"`
}

// PhotonPersistentDisk represents a PhotonController persistent disk attached and
// mounted on kubelets host machine
type SubscriptionSpecConfigVolumesElemPhotonPersistentDisk struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host
	// operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4"
	// if unspecified.
	FsType *string `json:"fsType,omitempty"`

	// ID that identifies Photon Controller persistent disk
	PdID string `json:"pdID"`
}

// PortworxVolume represents a portworx volume attached and mounted on kubelets
// host machine
type SubscriptionSpecConfigVolumesElemPortworxVolume struct {
	// FSType represents the filesystem type to mount Must be a filesystem type
	// supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred
	// to be "ext4" if unspecified.
	FsType *string `json:"fsType,omitempty"`

	// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
	// in VolumeMounts.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// VolumeID uniquely identifies a Portworx volume
	VolumeID string `json:"volumeID"`
}

// Items for all in one resources secrets, configmaps, and downward API
type SubscriptionSpecConfigVolumesElemProjected struct {
	// Mode bits used to set permissions on created files by default. Must be an octal
	// value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts
	// both octal and decimal values, JSON requires decimal values for mode bits.
	// Directories within the path are not affected by this setting. This might be in
	// conflict with other options that affect the file mode, like fsGroup, and the
	// result can be other mode bits set.
	DefaultMode *int `json:"defaultMode,omitempty"`

	// list of volume projections
	Sources []SubscriptionSpecConfigVolumesElemProjectedSourcesElem `json:"sources,omitempty"`
}

// Projection that may be projected along with other supported volume types
type SubscriptionSpecConfigVolumesElemProjectedSourcesElem struct {
	// information about the configMap data to project
	ConfigMap *SubscriptionSpecConfigVolumesElemProjectedSourcesElemConfigMap `json:"configMap,omitempty"`

	// information about the downwardAPI data to project
	DownwardAPI *SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPI `json:"downwardAPI,omitempty"`

	// information about the secret data to project
	Secret *SubscriptionSpecConfigVolumesElemProjectedSourcesElemSecret `json:"secret,omitempty"`

	// information about the serviceAccountToken data to project
	ServiceAccountToken *SubscriptionSpecConfigVolumesElemProjectedSourcesElemServiceAccountToken `json:"serviceAccountToken,omitempty"`
}

// information about the configMap data to project
type SubscriptionSpecConfigVolumesElemProjectedSourcesElemConfigMap struct {
	// If unspecified, each key-value pair in the Data field of the referenced
	// ConfigMap will be projected into the volume as a file whose name is the key and
	// content is the value. If specified, the listed keys will be projected into the
	// specified paths, and unlisted keys will not be present. If a key is specified
	// which is not present in the ConfigMap, the volume setup will error unless it is
	// marked optional. Paths must be relative and may not contain the '..' path or
	// start with '..'.
	Items []SubscriptionSpecConfigVolumesElemProjectedSourcesElemConfigMapItemsElem `json:"items,omitempty"`

	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `json:"name,omitempty"`

	// Specify whether the ConfigMap or its keys must be defined
	Optional *bool `json:"optional,omitempty"`
}

// Maps a string key to a path within a volume.
type SubscriptionSpecConfigVolumesElemProjectedSourcesElemConfigMapItemsElem struct {
	// The key to project.
	Key string `json:"key"`

	// Optional: mode bits used to set permissions on this file. Must be an octal
	// value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts
	// both octal and decimal values, JSON requires decimal values for mode bits. If
	// not specified, the volume defaultMode will be used. This might be in conflict
	// with other options that affect the file mode, like fsGroup, and the result can
	// be other mode bits set.
	Mode *int `json:"mode,omitempty"`

	// The relative path of the file to map the key to. May not be an absolute path.
	// May not contain the path element '..'. May not start with the string '..'.
	Path string `json:"path"`
}

// information about the downwardAPI data to project
type SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPI struct {
	// Items is a list of DownwardAPIVolume file
	Items []SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPIItemsElem `json:"items,omitempty"`
}

// DownwardAPIVolumeFile represents information to create the file containing the
// pod field
type SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPIItemsElem struct {
	// Required: Selects a field of the pod: only annotations, labels, name and
	// namespace are supported.
	FieldRef *SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPIItemsElemFieldRef `json:"fieldRef,omitempty"`

	// Optional: mode bits used to set permissions on this file, must be an octal
	// value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts
	// both octal and decimal values, JSON requires decimal values for mode bits. If
	// not specified, the volume defaultMode will be used. This might be in conflict
	// with other options that affect the file mode, like fsGroup, and the result can
	// be other mode bits set.
	Mode *int `json:"mode,omitempty"`

	// Required: Path is  the relative path name of the file to be created. Must not
	// be absolute or contain the '..' path. Must be utf-8 encoded. The first item of
	// the relative path must not start with '..'
	Path string `json:"path"`

	// Selects a resource of the container: only resources limits and requests
	// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently
	// supported.
	ResourceFieldRef *SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPIItemsElemResourceFieldRef `json:"resourceFieldRef,omitempty"`
}

// Required: Selects a field of the pod: only annotations, labels, name and
// namespace are supported.
type SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPIItemsElemFieldRef struct {
	// Version of the schema the FieldPath is written in terms of, defaults to "v1".
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Path of the field to select in the specified API version.
	FieldPath string `json:"fieldPath"`
}

// Selects a resource of the container: only resources limits and requests
// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently
// supported.
type SubscriptionSpecConfigVolumesElemProjectedSourcesElemDownwardAPIItemsElemResourceFieldRef struct {
	// Container name: required for volumes, optional for env vars
	ContainerName *string `json:"containerName,omitempty"`

	// Specifies the output format of the exposed resources, defaults to "1"
	Divisor apiextensions.JSON `json:"divisor,omitempty"`

	// Required: resource to select
	Resource string `json:"resource"`
}

// information about the secret data to project
type SubscriptionSpecConfigVolumesElemProjectedSourcesElemSecret struct {
	// If unspecified, each key-value pair in the Data field of the referenced Secret
	// will be projected into the volume as a file whose name is the key and content
	// is the value. If specified, the listed keys will be projected into the
	// specified paths, and unlisted keys will not be present. If a key is specified
	// which is not present in the Secret, the volume setup will error unless it is
	// marked optional. Paths must be relative and may not contain the '..' path or
	// start with '..'.
	Items []SubscriptionSpecConfigVolumesElemProjectedSourcesElemSecretItemsElem `json:"items,omitempty"`

	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `json:"name,omitempty"`

	// Specify whether the Secret or its key must be defined
	Optional *bool `json:"optional,omitempty"`
}

// Maps a string key to a path within a volume.
type SubscriptionSpecConfigVolumesElemProjectedSourcesElemSecretItemsElem struct {
	// The key to project.
	Key string `json:"key"`

	// Optional: mode bits used to set permissions on this file. Must be an octal
	// value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts
	// both octal and decimal values, JSON requires decimal values for mode bits. If
	// not specified, the volume defaultMode will be used. This might be in conflict
	// with other options that affect the file mode, like fsGroup, and the result can
	// be other mode bits set.
	Mode *int `json:"mode,omitempty"`

	// The relative path of the file to map the key to. May not be an absolute path.
	// May not contain the path element '..'. May not start with the string '..'.
	Path string `json:"path"`
}

// information about the serviceAccountToken data to project
type SubscriptionSpecConfigVolumesElemProjectedSourcesElemServiceAccountToken struct {
	// Audience is the intended audience of the token. A recipient of a token must
	// identify itself with an identifier specified in the audience of the token, and
	// otherwise should reject the token. The audience defaults to the identifier of
	// the apiserver.
	Audience *string `json:"audience,omitempty"`

	// ExpirationSeconds is the requested duration of validity of the service account
	// token. As the token approaches expiration, the kubelet volume plugin will
	// proactively rotate the service account token. The kubelet will start trying to
	// rotate the token if the token is older than 80 percent of its time to live or
	// if the token is older than 24 hours.Defaults to 1 hour and must be at least 10
	// minutes.
	ExpirationSeconds *int `json:"expirationSeconds,omitempty"`

	// Path is the path relative to the mount point of the file to project the token
	// into.
	Path string `json:"path"`
}

// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
type SubscriptionSpecConfigVolumesElemQuobyte struct {
	// Group to map volume access to Default is no group
	Group *string `json:"group,omitempty"`

	// ReadOnly here will force the Quobyte volume to be mounted with read-only
	// permissions. Defaults to false.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// Registry represents a single or multiple Quobyte Registry services specified as
	// a string as host:port pair (multiple entries are separated with commas) which
	// acts as the central registry for volumes
	Registry string `json:"registry"`

	// Tenant owning the given Quobyte volume in the Backend Used with dynamically
	// provisioned Quobyte volumes, value is set by the plugin
	Tenant *string `json:"tenant,omitempty"`

	// User to map volume access to Defaults to serivceaccount user
	User *string `json:"user,omitempty"`

	// Volume is a string that references an already created Quobyte volume by name.
	Volume string `json:"volume"`
}

// RBD represents a Rados Block Device mount on the host that shares a pod's
// lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
type SubscriptionSpecConfigVolumesElemRbd struct {
	// Filesystem type of the volume that you want to mount. Tip: Ensure that the
	// filesystem type is supported by the host operating system. Examples: "ext4",
	// "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent
	// errors in the filesystem from compromising the machine
	FsType *string `json:"fsType,omitempty"`

	// The rados image name. More info:
	// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	Image string `json:"image"`

	// Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More
	// info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	Keyring *string `json:"keyring,omitempty"`

	// A collection of Ceph monitors. More info:
	// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	Monitors []string `json:"monitors"`

	// The rados pool name. Default is rbd. More info:
	// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	Pool *string `json:"pool,omitempty"`

	// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to
	// false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	ReadOnly *bool `json:"readOnly,omitempty"`

	// SecretRef is name of the authentication secret for RBDUser. If provided
	// overrides keyring. Default is nil. More info:
	// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	SecretRef *SubscriptionSpecConfigVolumesElemRbdSecretRef `json:"secretRef,omitempty"`

	// The rados user name. Default is admin. More info:
	// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	User *string `json:"user,omitempty"`
}

// SecretRef is name of the authentication secret for RBDUser. If provided
// overrides keyring. Default is nil. More info:
// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
type SubscriptionSpecConfigVolumesElemRbdSecretRef struct {
	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `json:"name,omitempty"`
}

// ScaleIO represents a ScaleIO persistent volume attached and mounted on
// Kubernetes nodes.
type SubscriptionSpecConfigVolumesElemScaleIO struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host
	// operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
	FsType *string `json:"fsType,omitempty"`

	// The host address of the ScaleIO API Gateway.
	Gateway string `json:"gateway"`

	// The name of the ScaleIO Protection Domain for the configured storage.
	ProtectionDomain *string `json:"protectionDomain,omitempty"`

	// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
	// in VolumeMounts.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// SecretRef references to the secret for ScaleIO user and other sensitive
	// information. If this is not provided, Login operation will fail.
	SecretRef SubscriptionSpecConfigVolumesElemScaleIOSecretRef `json:"secretRef"`

	// Flag to enable/disable SSL communication with Gateway, default false
	SslEnabled *bool `json:"sslEnabled,omitempty"`

	// Indicates whether the storage for a volume should be ThickProvisioned or
	// ThinProvisioned. Default is ThinProvisioned.
	StorageMode *string `json:"storageMode,omitempty"`

	// The ScaleIO Storage Pool associated with the protection domain.
	StoragePool *string `json:"storagePool,omitempty"`

	// The name of the storage system as configured in ScaleIO.
	System string `json:"system"`

	// The name of a volume already created in the ScaleIO system that is associated
	// with this volume source.
	VolumeName *string `json:"volumeName,omitempty"`
}

// SecretRef references to the secret for ScaleIO user and other sensitive
// information. If this is not provided, Login operation will fail.
type SubscriptionSpecConfigVolumesElemScaleIOSecretRef struct {
	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `json:"name,omitempty"`
}

// Secret represents a secret that should populate this volume. More info:
// https://kubernetes.io/docs/concepts/storage/volumes#secret
type SubscriptionSpecConfigVolumesElemSecret struct {
	// Optional: mode bits used to set permissions on created files by default. Must
	// be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
	// YAML accepts both octal and decimal values, JSON requires decimal values for
	// mode bits. Defaults to 0644. Directories within the path are not affected by
	// this setting. This might be in conflict with other options that affect the file
	// mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode *int `json:"defaultMode,omitempty"`

	// If unspecified, each key-value pair in the Data field of the referenced Secret
	// will be projected into the volume as a file whose name is the key and content
	// is the value. If specified, the listed keys will be projected into the
	// specified paths, and unlisted keys will not be present. If a key is specified
	// which is not present in the Secret, the volume setup will error unless it is
	// marked optional. Paths must be relative and may not contain the '..' path or
	// start with '..'.
	Items []SubscriptionSpecConfigVolumesElemSecretItemsElem `json:"items,omitempty"`

	// Specify whether the Secret or its keys must be defined
	Optional *bool `json:"optional,omitempty"`

	// Name of the secret in the pod's namespace to use. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#secret
	SecretName *string `json:"secretName,omitempty"`
}

// Maps a string key to a path within a volume.
type SubscriptionSpecConfigVolumesElemSecretItemsElem struct {
	// The key to project.
	Key string `json:"key"`

	// Optional: mode bits used to set permissions on this file. Must be an octal
	// value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts
	// both octal and decimal values, JSON requires decimal values for mode bits. If
	// not specified, the volume defaultMode will be used. This might be in conflict
	// with other options that affect the file mode, like fsGroup, and the result can
	// be other mode bits set.
	Mode *int `json:"mode,omitempty"`

	// The relative path of the file to map the key to. May not be an absolute path.
	// May not contain the path element '..'. May not start with the string '..'.
	Path string `json:"path"`
}

// StorageOS represents a StorageOS volume attached and mounted on Kubernetes
// nodes.
type SubscriptionSpecConfigVolumesElemStorageos struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host
	// operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4"
	// if unspecified.
	FsType *string `json:"fsType,omitempty"`

	// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
	// in VolumeMounts.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// SecretRef specifies the secret to use for obtaining the StorageOS API
	// credentials.  If not specified, default values will be attempted.
	SecretRef *SubscriptionSpecConfigVolumesElemStorageosSecretRef `json:"secretRef,omitempty"`

	// VolumeName is the human-readable name of the StorageOS volume.  Volume names
	// are only unique within a namespace.
	VolumeName *string `json:"volumeName,omitempty"`

	// VolumeNamespace specifies the scope of the volume within StorageOS.  If no
	// namespace is specified then the Pod's namespace will be used.  This allows the
	// Kubernetes name scoping to be mirrored within StorageOS for tighter
	// integration. Set VolumeName to any name to override the default behaviour. Set
	// to "default" if you are not using namespaces within StorageOS. Namespaces that
	// do not pre-exist within StorageOS will be created.
	VolumeNamespace *string `json:"volumeNamespace,omitempty"`
}

// SecretRef specifies the secret to use for obtaining the StorageOS API
// credentials.  If not specified, default values will be attempted.
type SubscriptionSpecConfigVolumesElemStorageosSecretRef struct {
	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `json:"name,omitempty"`
}

// VsphereVolume represents a vSphere volume attached and mounted on kubelets host
// machine
type SubscriptionSpecConfigVolumesElemVsphereVolume struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host
	// operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4"
	// if unspecified.
	FsType *string `json:"fsType,omitempty"`

	// Storage Policy Based Management (SPBM) profile ID associated with the
	// StoragePolicyName.
	StoragePolicyID *string `json:"storagePolicyID,omitempty"`

	// Storage Policy Based Management (SPBM) profile name.
	StoragePolicyName *string `json:"storagePolicyName,omitempty"`

	// Path that identifies vSphere volume vmdk
	VolumePath string `json:"volumePath"`
}

type SubscriptionStatus struct {
	// CatalogHealth contains the Subscription's view of its relevant CatalogSources'
	// status. It is used to determine SubscriptionStatusConditions related to
	// CatalogSources.
	CatalogHealth []SubscriptionStatusCatalogHealthElem `json:"catalogHealth,omitempty"`

	// Conditions is a list of the latest available observations about a
	// Subscription's current state.
	Conditions []SubscriptionStatusConditionsElem `json:"conditions,omitempty"`

	// CurrentCSV is the CSV the Subscription is progressing to.
	CurrentCSV *string `json:"currentCSV,omitempty"`

	// InstallPlanGeneration is the current generation of the installplan
	InstallPlanGeneration *int `json:"installPlanGeneration,omitempty"`

	// InstallPlanRef is a reference to the latest InstallPlan that contains the
	// Subscription's current CSV.
	InstallPlanRef *SubscriptionStatusInstallPlanRef `json:"installPlanRef,omitempty"`

	// InstalledCSV is the CSV currently installed by the Subscription.
	InstalledCSV *string `json:"installedCSV,omitempty"`

	// Install is a reference to the latest InstallPlan generated for the
	// Subscription. DEPRECATED: InstallPlanRef
	Installplan *SubscriptionStatusInstallplan `json:"installplan,omitempty"`

	// LastUpdated represents the last time that the Subscription status was updated.
	LastUpdated string `json:"lastUpdated"`

	// Reason is the reason the Subscription was transitioned to its current state.
	Reason *string `json:"reason,omitempty"`

	// State represents the current state of the Subscription
	State *string `json:"state,omitempty"`
}

// SubscriptionCatalogHealth describes the health of a CatalogSource the
// Subscription knows about.
type SubscriptionStatusCatalogHealthElem struct {
	// CatalogSourceRef is a reference to a CatalogSource.
	CatalogSourceRef SubscriptionStatusCatalogHealthElemCatalogSourceRef `json:"catalogSourceRef"`

	// Healthy is true if the CatalogSource is healthy; false otherwise.
	Healthy bool `json:"healthy"`

	// LastUpdated represents the last time that the CatalogSourceHealth changed
	LastUpdated string `json:"lastUpdated"`
}

// CatalogSourceRef is a reference to a CatalogSource.
type SubscriptionStatusCatalogHealthElemCatalogSourceRef struct {
	// API version of the referent.
	ApiVersion *string `json:"apiVersion,omitempty"`

	// If referring to a piece of an object instead of an entire object, this string
	// should contain a valid JSON/Go field access statement, such as
	// desiredState.manifest.containers[2]. For example, if the object reference is to
	// a container within a pod, this would take on a value like:
	// "spec.containers{name}" (where "name" refers to the name of the container that
	// triggered the event) or if no container name is specified "spec.containers[2]"
	// (container with index 2 in this pod). This syntax is chosen only to have some
	// well-defined way of referencing a part of an object. TODO: this design is not
	// final and this field is subject to change in the future.
	FieldPath *string `json:"fieldPath,omitempty"`

	// Kind of the referent. More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `json:"kind,omitempty"`

	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `json:"name,omitempty"`

	// Namespace of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace *string `json:"namespace,omitempty"`

	// Specific resourceVersion to which this reference is made, if any. More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `json:"resourceVersion,omitempty"`

	// UID of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid *string `json:"uid,omitempty"`
}

// SubscriptionCondition represents the latest available observations of a
// Subscription's state.
type SubscriptionStatusConditionsElem struct {
	// LastHeartbeatTime is the last time we got an update on a given condition
	LastHeartbeatTime *string `json:"lastHeartbeatTime,omitempty"`

	// LastTransitionTime is the last time the condition transit from one status to
	// another
	LastTransitionTime *string `json:"lastTransitionTime,omitempty"`

	// Message is a human-readable message indicating details about last transition.
	Message *string `json:"message,omitempty"`

	// Reason is a one-word CamelCase reason for the condition's last transition.
	Reason *string `json:"reason,omitempty"`

	// Status is the status of the condition, one of True, False, Unknown.
	Status string `json:"status"`

	// Type is the type of Subscription condition.
	Type string `json:"type"`
}

// InstallPlanRef is a reference to the latest InstallPlan that contains the
// Subscription's current CSV.
type SubscriptionStatusInstallPlanRef struct {
	// API version of the referent.
	ApiVersion *string `json:"apiVersion,omitempty"`

	// If referring to a piece of an object instead of an entire object, this string
	// should contain a valid JSON/Go field access statement, such as
	// desiredState.manifest.containers[2]. For example, if the object reference is to
	// a container within a pod, this would take on a value like:
	// "spec.containers{name}" (where "name" refers to the name of the container that
	// triggered the event) or if no container name is specified "spec.containers[2]"
	// (container with index 2 in this pod). This syntax is chosen only to have some
	// well-defined way of referencing a part of an object. TODO: this design is not
	// final and this field is subject to change in the future.
	FieldPath *string `json:"fieldPath,omitempty"`

	// Kind of the referent. More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `json:"kind,omitempty"`

	// Name of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `json:"name,omitempty"`

	// Namespace of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace *string `json:"namespace,omitempty"`

	// Specific resourceVersion to which this reference is made, if any. More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `json:"resourceVersion,omitempty"`

	// UID of the referent. More info:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid *string `json:"uid,omitempty"`
}

// Install is a reference to the latest InstallPlan generated for the Subscription.
// DEPRECATED: InstallPlanRef
type SubscriptionStatusInstallplan struct {
	// ApiVersion corresponds to the JSON schema field "apiVersion".
	ApiVersion string `json:"apiVersion"`

	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name"`

	// UID is a type that holds unique ID values, including UUIDs.  Because we don't
	// ONLY use UUIDs, this is an alias to string.  Being a type captures intent and
	// helps make sure that UIDs and names do not get conflated.
	Uuid string `json:"uuid"`
}
