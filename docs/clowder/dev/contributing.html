<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Developing for Clowder :: Clowder Documentation</title>
    <link rel="canonical" href="https://redhatinsights.github.io/clowder/clowder/dev/contributing.html">
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../../ui/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://redhatinsights.github.io/clowder">Clowder Documentation</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="clowder" data-version="dev">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">Clowder</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="api_reference.html">API Reference</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="contributing.html">Contributing</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="developer-guide.html">Developer Guide</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="crc-guide.html">CodeReady Containers Guide</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="sop.html">SOP</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="faq.html">FAQ</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="migration/index.html">Migration</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="migration/migration.html">Migration Docs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="migration/checklist.html">Check List</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="providers/index.html">Providers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="providers/confighash.html">Config Hash</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="providers/cronjob.html">CronJob</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="providers/database.html">Database</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="providers/dependencies.html">Dependencies</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="providers/deployment.html">Deployment</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="providers/featureflags.html">Feature Flags</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="providers/inmemorydb.html">In-Memory DB</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="providers/kafka.html">Kafka</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="providers/logging.html">Logging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="providers/metrics.html">Metrics</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="providers/objectstore.html">Object Storage</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="providers/serviceaccount.html">Service Accounts</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="providers/servicemesh.html">Service Mesh</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="providers/web.html">Web</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="usage/index.html">Usage</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="usage/app-workflow.html">App Workflow</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="usage/getting-started.html">Getting Started</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="usage/jobs.html">Jobs</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Clowder</span>
    <span class="version">dev</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="index.html">Clowder</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">dev</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Clowder</a></li>
    <li><a href="contributing.html">Contributing</a></li>
  </ul>
</nav>
<div class="edit-this-page"><a href="https://github.com/RedHatInsights/clowder/edit/master/docs/antora/modules/ROOT/pages/contributing.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Developing for Clowder</h1>
<div class="sect1">
<h2 id="_providers"><a class="anchor" href="#_providers"></a>Providers</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_provider_setup"><a class="anchor" href="#_provider_setup"></a>Provider setup</h3>
<div class="paragraph">
<p>The core of Clowder revolves around a core concept of providers. Clowder splits its functionality
into multiple units called providers. These are called in a defined order and provide both
environmental and application level resources, as well as configuration that ultimately lands in the
<code>cdappconfig.json</code>.</p>
</div>
<div class="paragraph">
<p>The providers live in the <code>controllers/cloud.redhat.com/providers</code> folder and comprise of a
<code>provider.go</code> file, some mode files, some implementation files and potentially some tests too.</p>
</div>
<div class="paragraph">
<p>The <code>provider.go</code> defines several key pieces. Shown below is the <code>deployment</code> provider&#8217;s
<code>provider.go</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-golang hljs" data-lang="golang">package deployment

import (
	rc "github.com/RedHatInsights/rhc-osdk-utils/resourceCache"
    p "cloud.redhat.com/clowder/v2/controllers/cloud.redhat.com/providers"
    apps "k8s.io/api/apps/v1"
)

// ProvName sets the provider name identifier
var ProvName = "deployment"

// CoreDeployment is the deployment for the apps deployments.
var CoreDeployment = rc.NewMultiResourceIdent(ProvName, "core_deployment", &amp;apps.Deployment{})

// GetEnd returns the correct end provider.
func GetDeployment(c *p.Provider) (p.ClowderProvider, error) {
    return NewDeploymentProvider(c)
}

func init() {
    p.ProvidersRegistration.Register(GetDeployment, 0, ProvName)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ProvName</code> is an identifier that defines the name of the provider. Notice that the Golang
pacakge name is the same as this identifier. This is a nice convention and one which should be
maintained when new providers are added. The next declaration is a MultiResourceIdent. These will be
discussed in a little mroe detail below, but in short, this is a declaration of the resources that
this particular provider will create.</p>
</div>
<div class="paragraph">
<p>After that there is the <code>GetDeployment()</code> function. Every provider has some kind of <code>Get*()</code>
function, which is responsible for creating deciding which mode to run the provider in. Depending on
the environmental settings, providers can be run in different modes. The <code>deployment</code> provider is
a core provider and as such as no modal configuration, i.e. there is only one mode. Providers with
no modes will use the <code>default.go</code> to provide their functionality. The <code>Get*()</code> function returns
a Provider object. In this case the function is called <code>NewDeploymentProvider()</code> and returns the
default <code>DeploymentProvider</code> object. This will be expanded upon shortly.</p>
</div>
<div class="paragraph">
<p>The <code>init()</code> call is responsible for registering this provider with the internal provider
registration system. The provider&#8217;s <code>Get*()</code> function is passed in, as well as an integer and the
<code>ProvName</code>. The integer specifies the order in which the providers should be run. <code>0</code> is the
first provider and <code>99</code>, by convention, is the last. Two providers can share the same order
number.</p>
</div>
<div class="paragraph">
<p>Care must be taken when providers depend on each others resources, that they are executed in the
correct order, otherwise the dependant provider will fail when its dependency is missing from the
cache. This will be explained in more depth in the caching section later in this document.</p>
</div>
</div>
<div class="sect2">
<h3 id="_provider_functionality"><a class="anchor" href="#_provider_functionality"></a>Provider functionality</h3>
<div class="paragraph">
<p>The <code>default.go</code> file is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-golang hljs" data-lang="golang">package deployment

import (
    crd "cloud.redhat.com/clowder/v2/apis/cloud.redhat.com/v1alpha1"
    "cloud.redhat.com/clowder/v2/controllers/cloud.redhat.com/config"
    p "cloud.redhat.com/clowder/v2/controllers/cloud.redhat.com/providers"
)

type deploymentProvider struct {
    p.Provider
}

func NewDeploymentProvider(p *p.Provider) (p.ClowderProvider, error) {
    return &amp;deploymentProvider{Provider: *p}, nil
}

func (dp *deploymentProvider) Provide(app *crd.ClowdApp, c *config.AppConfig) error {

    for _, deployment := range app.Spec.Deployments {

        if err := dp.makeDeployment(deployment, app); err != nil {
            return err
        }
    }
    return nil
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>default.go</code> file defines a singular mode for a provider. In other providers there may be
several modes and each of these will be housed in its own <code>.go</code> file, though it will be a part of
the same package. The <code>deploymentProvider</code> struct defines an struct to which functions are
attached for provider operation. Some of these can be internal, but the most important one is called
<code>Provide</code> and must be exported.</p>
</div>
<div class="paragraph">
<p>When the providers are <em>invoked</em> in Clowder, they are done so in the two controllers,
<code>ClowdEnvironment</code> and <code>ClowdApp</code>. The <code>ClowdEnvironment</code> controller only runs the
<em>environmental</em> functionality to provider environmental resources. An example of this would be a
kafka or obejct storage server, as there is only ever one of these per environment. The
<code>NewDeploymentProvider()</code> function, as referenced in the previous <code>provider.go</code> file, is
responsible for creating and managing these <em>environment</em> level resources. These are run by the
<em>environment</em> controller and will be reconciled whenever the <code>ClowdEnvironment</code> is triggered.</p>
</div>
<div class="paragraph">
<p>By contrast, <code>ClowdApp</code> modifications trigger the <em>application</em> reconciliation, which first runs
the <em>environment</em> function, in this case <code>NewDeploymentProvider()</code> before then running the
<code>Provide()</code> function. This may seem odd and indeed is a design quirk of Clowder that iwill
hopefully be resolved in a later release. Its reasoning is that the environmental resources often
need to provide information to the application level reconciliation, for instance to furnish the
<code>cdappconfig</code> with the Kafka broker address. Since this information is calculated by the
environment controller, the application controller must first rerun the environment controller&#8217;s
functions to obtain the information.</p>
</div>
<div class="paragraph">
<p>Environment and application level functions can access and edit the <code>AppConfig</code> object which will
ultimately be transformed into the <code>cdappconfig.json</code> file that ends up in the app container at
runtime.</p>
</div>
</div>
<div class="sect2">
<h3 id="_caching_resources"><a class="anchor" href="#_caching_resources"></a>Caching resources</h3>
<div class="paragraph">
<p>A key tenet of the Clowder provider system is that of sharing resources. Without resource sharing,
providers that need to modify the resources of other providers result not only in multiple calls to
update the same resources, but also can potentially trigger multiple reconciliations as updates to
Clowder owned resources can trigger these.</p>
</div>
<div class="paragraph">
<p>To reduce this burden, the Clowder system will onyl apply resources at the very end of the
reconciliation. Until that time, resources are stored in the resource cache and providers are able
to retrieve objects from this cache, update them, and then placed the updated versions back in the
cache, so that their changes will be applied at the end of the reconciliation. This is where the
order of provider invocation is important.</p>
</div>
<div class="paragraph">
<p>The following is a snippet from the <code>deployment</code> provider&#8217;s <code>provider.go</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-golang hljs" data-lang="golang">// CoreDeployment is the deployment for the apps deployments.
var CoreDeployment = p.NewMultiResourceIdent(ProvName, "core_deployment", &amp;apps.Deployment{})</code></pre>
</div>
</div>
<div class="paragraph">
<p>This was shown previously and is responsible for creating an object that can identify certain
resources. The call takes three arguments: the provider name, a purpose string (which details
briefly what the resource is used for), and a <em>template</em> object.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The template object is never <strong>used</strong> in anyway. It is merely there to determine the type of the resource.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the <code>impl.go</code> of the provider the resource identifier is used to <em>create</em> the object in the
cache.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-golang hljs" data-lang="golang">d := &amp;apps.Deployment{}
nn := app.GetDeploymentNamespacedName(&amp;deployment)

if err := dp.Cache.Create(CoreDeployment, nn, d); err != nil {
    return err
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice a new <code>Deployment</code> struct is created, along with a namespaced name, and these, together
with the resource identifier, are passed to the <code>Create()</code> function. This will create a map in the
resource cache map for this provider resource if it does not already exist, and furnish it with a
key value pair of the namespaced name, and a copy of the deployment retrieved from k8s. It does not
simply create a blank entry, it first tries to obtain a copy from k8s.</p>
</div>
<div class="paragraph">
<p>The object is then modified, before the following call being made:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-golang hljs" data-lang="golang">if err := dp.Cache.Update(CoreDeployment, d); err != nil {
    return err
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This call sends the object back to the cache where it is copied.</p>
</div>
<div class="paragraph">
<p>When another provider wishes to apply updates to this resource, it first needs to retrieve it from the cache. A very simliar example may be seen in the
<code>serviceaccount</code> provider:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-golang hljs" data-lang="golang">dList := &amp;apps.DeploymentList{}
if err := sa.Cache.List(deployment.CoreDeployment, dList); err != nil {
    return err
}
for _, d := range dList.Items {
    d.Spec.Template.Spec.ServiceAccountName = app.GetClowdSAName()
    if err := sa.Cache.Update(deployment.CoreDeployment, &amp;d); err != nil {
        return err
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the resource was created above as a <code>Multi</code> resource, the retrieval from the cache must either
use the <code>List()</code> function, or the <code>Get()</code> function and supply a <code>NamespacedName</code>. A <strong>Multi</strong>
resource is one which is expected to hold multiple resources of the same type, but obviously with
different names. If these resources are required to be updated, then an <code>Update()</code> call is
necessary on each one as can be seen above.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pull_request_flow"><a class="anchor" href="#_pull_request_flow"></a>Pull Request Flow</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Changes to the Clowder codebase can be broken down into three distinct categories. Each of these
is treated in a slightly different way with regards to signoff and review. The goal of this is to
reduce the size of pull requests to allow code to be merged faster and make production pushes less
dramatic.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Typo/Docs</strong> No detailed explanation/justification needed</p>
</li>
<li>
<p><strong>Functional Change</strong> any significant modification to code that gets compiled (i.e. anything over
typo/code style changes) requires a good commit message, detailing functions that have been altered,
behaviour that has changed, etc, a set of functional tests added to the e2e suite, with unit tests
optional, and should be reviewed by at least one Clowder core developer.</p>
</li>
<li>
<p><strong>Architectural Change</strong> anything more advanced than a functional change, which typically
includes, any changes to API specs or changes to external behaviour that is observable by a
customer, should have architect sign off, must be run locally to validate tests and behaviour, must
include any deprecations, should have a design doc, and must be reviewed by two clowder core
developers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All PRs should be squashed to as few commits as makes sense to a) keep the version history clean
and b) assist with any reverts/cherrypicks that need to happen.
== Testing</p>
</div>
<div class="paragraph">
<p>Clowder testing utilises two main testing techniques:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Unit tests</strong> - small fast tests of individual functions</p>
</li>
<li>
<p><strong>Kuttl/E2E tests</strong> - E2E tests run in a real cluster</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The development of tests for these two categories, the sections below detail
some of the development flows for writing tests.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing"><a class="anchor" href="#_testing"></a>Testing</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_types_of_tests"><a class="anchor" href="#_types_of_tests"></a>Types of tests</h3>
<div class="sect3">
<h4 id="_unit_tests"><a class="anchor" href="#_unit_tests"></a>Unit tests</h4>
<div class="paragraph">
<p>The <code>controllers/cloud.redhat.com/suite_test.go</code> is the test file for most of
the top level functions in Clowder. Some providers also have their own test
files to assert specific functionality. This suite does have an etcd process
initiated as part of the test run, but does not have any operators running as
you would expect on a cluster. For example, if a Deployment resource is created
and applied, a Pod resource will NOT be created as it otherwise would be. If
specific functionality is expected to be tested like this, the Kuttl/E2E tests
should be used.</p>
</div>
</div>
<div class="sect3">
<h4 id="_kuttle2e_tests"><a class="anchor" href="#_kuttle2e_tests"></a>Kuttl/E2E tests</h4>
<div class="paragraph">
<p>The E2E tests make use of the Kuttl suite to test the application and
subsequent result of applying certain resources in a cluster which is running
the Clowder operator. Kuttl applies certain resources, and then asserts that
the resulting resources match those specified. It is suggested to look at the
many examples in the <code>bundle/tests/scoredcard/kuttl</code> directory. They are
generally broken down into the following structure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">kuttl/
└── test-name/
    ├── 00-install.yaml
    ├── 01-pods.yaml
    ├── 01-assert.yaml
    ├── 02-json-asserts.yaml
    └── 03-delete.yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p>The numerals infront of the test steps define the order Kuttle will invoke
them. The only specially named files are the <code>*-assert</code> files, which are
always run last. Sometimes the ordering is forced, e.g. you will usually see
the <code>delete</code> files in a separate step at the end to clean up as best it can.</p>
</div>
</div>
<div class="sect3">
<h4 id="_00_install_yaml"><a class="anchor" href="#_00_install_yaml"></a><code>00-install.yaml</code></h4>
<div class="paragraph">
<p>Kuttl usually creates a random namespace for a particular test, but in the
Clowder E2E test suite, the name is required for certain assertions and Kuttl
lacks the means for the E2E suite to reliably retrieve it. The
<code>00-install.yaml</code> file usually contains a namespace definition that houses
the test input and output resources.</p>
</div>
</div>
<div class="sect3">
<h4 id="_01_pods_yaml"><a class="anchor" href="#_01_pods_yaml"></a><code>01-pods.yaml</code></h4>
<div class="paragraph">
<p>Called <code>pods</code> because it will usually contain the definitions that will lead
to pods being created.</p>
</div>
</div>
<div class="sect3">
<h4 id="_01_assert_yaml"><a class="anchor" href="#_01_assert_yaml"></a><code>01-assert.yaml</code></h4>
<div class="paragraph">
<p>The resources in this file ill be compared to the ones in the cluster. Kuttl
will wait for a period of time until the resources in the cluster match the
resources in the file. If they do not match when the timeout occurs, the test
is said to have failed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_02_json_asserts_yaml"><a class="anchor" href="#_02_json_asserts_yaml"></a><code>02-json-asserts.yaml</code></h4>
<div class="paragraph">
<p>This is a hack as when Kuttl was first introduced it could not run commands as
tests, only as steps in preparing environments. As the inability to complete a
command would halt the test with a failure, the <code>json-asserts</code> files are
often used to assert that certain pieces of the JSON (cdappconfig.json) secret
are correct. As these are base64 encoded and contain a blob of data, Kuttl has
no way of matching the resource, so we use the <code>jq</code> command to assert
instead.</p>
</div>
</div>
<div class="sect3">
<h4 id="_03_delete_yaml"><a class="anchor" href="#_03_delete_yaml"></a><code>03-delete.yaml</code></h4>
<div class="paragraph">
<p>Deletions of the namespace and other resources allow the minikube environment
to be kept as clean as possible during the test run. Leaving pods only
increases resource usage unnecessarily.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_running_tests"><a class="anchor" href="#_running_tests"></a>Running tests</h3>
<div class="paragraph">
<p>To invoke either the unit tests, or the Kuttl tests, the kubebuilder assets are
required to either be on path, or an environment variable needs to be set to
point to them. The example below shows how to run the unit tests by setting the
environment variable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">KUBEBUILDER_ASSETS=~/kubebuilder_2.3.1_linux_amd64/bin/ make test</code></pre>
</div>
</div>
<div class="paragraph">
<p>Running the Kuttl tests requires a cluster to be present. It is possible to run
the Kuttl tests with a simple mocked backplane, but with the complex
integration between multiple operators, the Kuttl tests in Clowder are run
against minikube. With a minikube instance installed and configure as the
default for <code>kubectl</code>, the following command will run <strong>all</strong> the e2e tests.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">KUBEBUILDER_ASSETS=~/kubebuilder_2.3.1_linux_amd64/bin/ \
    kubectl kuttl test \
    --config tests/kuttl/kuttl-test.yaml \
    --manifest-dir config/crd/bases/ \
    --manifest-dir config/crd/static/ \
    tests/kuttl/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Single tests can be targetted using the <code>--test</code> command line flag and using
the name of the directory of the test to be run.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../ui/js/site.js" data-ui-root-path="../../ui"></script>
<script async src="../../ui/js/vendor/highlight.js"></script>
  </body>
</html>
